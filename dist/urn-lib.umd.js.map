{"version":3,"sources":["webpack://urn-lib/webpack/universalModuleDefinition","webpack://urn-lib/./src/lib/format.ts","webpack://urn-lib/./src/lib/parse.ts","webpack://urn-lib/./src/lib/validate.ts","webpack://urn-lib/./src/schemes/rfc2141.ts","webpack://urn-lib/webpack/bootstrap","webpack://urn-lib/./src/main.ts"],"names":["root","factory","exports","module","define","amd","a","i","self","protocol","components","separator","parsed","isString","Error","map","name","join","value","Array","isArray","length","parts","split","shift","len","isProtocol","toLowerCase","isValid","propertyName","allowZeroLength","RFC2141_NID_VALID","rule","failureMessage","test","str","strictMode","chr","indexOf","customRules","errors","Object","keys","forEach","push","err","message","PREFIX","SEPARATOR","COMPONENTS","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","generateDefaultValidationRules","lastIndex","rules","isRfc2141NidString","build","data","result","create","options","allowEmpty","validationRules","validationRuleObjectToArray","validate","urnObject","bind","format","formatUrn","parse","parseUrn","RFC2141"],"mappings":"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","file":"urn-lib.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","import { Item } from '../typings';\nimport { isString } from './validate';\n\nexport function formatUrn(\n  protocol: null | string,\n  components: string[],\n  separator: string,\n  parsed: Item<string, null | string>\n): string {\n  protocol = parsed && parsed.protocol ? parsed.protocol : protocol;\n  if (!isString(protocol)) throw new Error('protocol is missing or invalid');\n  return protocol + separator + components.map(name => !isString(parsed[name]) ? '' : parsed[name]).join(separator);\n}\n","import { Item } from '../typings';\nimport { isString } from './validate';\n\nexport function parseUrn(\n  components: string[],\n  separator: string,\n  value: unknown\n): null | Item<string, null | string> {\n  if (!Array.isArray(components) || components.length < 1) throw new Error('components not valid');\n  if (!isString(value)) return null;\n  const parts = value.split(separator);\n  if (parts.length < 2) return null;\n  const protocol = parts.shift(); // all schemes have a protocol\n  const parsed: Item<string, null | string> = { protocol };\n  const len = components.length - 1; // last component treated differently\n  for (let i=0; i < len; i++) {\n    const name = components[i];\n    parsed[name] = parts.length ? parts.shift() : null;\n  }\n  // concat last component.  anything beyond what's defined in components\n  // is a single string that belongs to last part\n  const lastPartName = components[len];\n  parsed[lastPartName]  = parts.length ? parts.join(separator) : null;\n  return parsed;\n}\n","import { Item, ValidationRule, ValidationRuleObject } from '../typings';\n\nexport const RFC2141_NID_VALID = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-';\n\nexport function validationRuleObjectToArray(rule: ValidationRuleObject | ValidationRule): ValidationRule {\n  if (Array.isArray(rule)) {\n    return rule;\n  }\n  return [rule.name, rule.failureMessage, rule.test];\n}\n\nexport function isRfc2141NidString(\n  str: unknown,\n  strictMode: boolean = false\n) {\n  if (true === strictMode) {\n    if (!isString(str)) return false;\n    // https://www.ietf.org/rfc/rfc2141.txt Section 2.1\n    if (str.length < 1) {\n      return false;\n    }\n    if (str.length > 31) {\n      return false;\n    }\n    // To avoid confusion with the \"urn:\" identifier, the NID \"urn\" is\n    // reserved and MUST NOT be used.\n    if ('urn' === str.toLowerCase()) {\n      return false;\n    }\n  }\n  str = str ?? '';\n  if (!isString(str)) return false;\n  if (str[0] === '-') return false;\n  for (const chr of str) {\n    if (RFC2141_NID_VALID.indexOf(chr) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nexport function isProtocol(\n  protocol: string,\n  parsed: Item<string, unknown>\n): boolean {\n  const value = parsed.protocol;\n  if (!isString(value)) return false;\n  return protocol.toLowerCase() === value.toLowerCase();\n}\n\nexport function isValid(\n  parsed: Item<string, unknown>,\n  propertyName: string,\n  allowZeroLength: boolean = false\n): boolean {\n  const value = parsed[propertyName];\n  return isString(value) && (allowZeroLength || value.length > 0);\n}\n\nexport function urnObject(\n  protocol: string,\n  customRules: ValidationRule[],\n  allowZeroLength: boolean,\n  parsed: Item<string, unknown>\n): null | string[] {\n  const errors: string[] = [];\n  Object.keys(parsed)\n    .forEach(propertyName => {\n      if (!isValid(parsed, propertyName, allowZeroLength)) {\n        errors.push(`validation failed for ${propertyName}: invalid value`);\n      }\n    });\n  if (!isProtocol(protocol, parsed)) {\n    errors.push(`validation failed for protocol: expected ${protocol} but got ${parsed.protocol}`);\n  }\n  customRules\n    .forEach(rule => {\n      const [propertyName, failureMessage, test] = rule;\n      try {\n        const value = parsed[propertyName];\n        if (true !== test(value)) {\n          errors.push(`validation failed for ${propertyName}: ${failureMessage}`);\n        }\n      }\n      catch(err) {\n        errors.push(`validation error for ${propertyName}: ${err.message}`);\n      }\n    });\n  return errors.length ? errors : null;\n}\n","import { ParsedUrn } from '../typings';\n\nexport const PREFIX = 'urn';\nexport const SEPARATOR = ':';\n\nexport interface IParsedRfc2141Components {\n  nid: string;\n  nss: string;\n}\n\nexport type ParsedRfc2141 = ParsedUrn<typeof PREFIX, IParsedRfc2141Components>;\n\nexport const COMPONENTS: (keyof IParsedRfc2141Components)[] = [\n  'nid',\n  'nss',\n];\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { formatUrn } from './lib/format';\nimport { parseUrn } from './lib/parse';\nimport { urnObject, isRfc2141NidString, isString, validationRuleObjectToArray } from './lib/validate';\nimport { PREFIX as RFC2141_PREFIX, SEPARATOR as RFC2141_SEPARATOR, COMPONENTS as RFC2141_COMPONENTS } from './schemes/rfc2141';\nimport { Item, ValidationRule, ValidationRuleObject } from './typings';\n\n// generates an array of rules that treats all but the last component\n// as an nid string (with limited valid charset)\nexport function generateDefaultValidationRules(components: string[]): ValidationRule[] {\n  const lastIndex = components.length - 1;\n  const rules: ValidationRule[] = [];\n  for (let i=0; i < lastIndex; i++) {\n    const name = components[i];\n    rules.push([ name, 'invalid characters', (value: unknown) => isRfc2141NidString(value, false) ]);\n  }\n  return rules;\n}\n\nfunction build(\n  protocol: string,\n  components: string[],\n  data: Item<string, unknown> = {}\n): Item<string, null | string> {\n  data = data || {};\n  const result: Item<string, null | string> = { protocol };\n  components\n    .forEach(name => {\n      const value = data[name];\n      result[name] = isString(value) ? value : null;\n    });\n  return result;\n}\n\nexport type UrnLibOptions = Partial<{\n  components: string[];\n  allowEmpty: boolean;\n  separator: string;\n  validationRules: (ValidationRule | ValidationRuleObject)[];\n}>;\n\nexport function create(\n  protocol: string,\n  options?: UrnLibOptions\n) {\n  options = options || {};\n  const components = options.components || RFC2141_COMPONENTS;\n  const allowEmpty = options.allowEmpty ?? false;\n  const separator = options.separator ?? RFC2141_SEPARATOR;\n  const rawValidationRules = options.validationRules || generateDefaultValidationRules(components);\n  const validationRules = rawValidationRules\n    .map(rule =>\n      validationRuleObjectToArray(rule));\n  return {\n    validate:   urnObject.bind(null, protocol, validationRules, allowEmpty),\n    format:     formatUrn.bind(null, protocol, components, separator),\n    parse:      parseUrn.bind(null, components, separator),\n    build:      build.bind(null, protocol, components),\n  };\n}\n\nexport const RFC2141 = create(RFC2141_PREFIX, {\n  components:       RFC2141_COMPONENTS,\n  separator:        RFC2141_SEPARATOR,\n  allowEmpty:       false,\n});\n"],"sourceRoot":""}